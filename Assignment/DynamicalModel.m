function [state_derivative, state_out] = DynamicalModel(voltages, state, stepSize_time)
%DYNAMICALMODEL - Calculate state at next time step
%
% Syntax: [state_derivative, state_out] = DynamicalModel(voltages, state, stepSize_time)

% Inputs: 
%   voltages            voltages of all 4 wheels
%                          [voltageLeft, voltageLeft, voltageRight, voltageRight]
%                          for this lab both motors on either side have the same voltage
%   state               current state at this time step, VARIABLES OF IMPORTANCE:
%                          state(13): forward velocity,    v, m/s
%                          state(18): rotational velocity, r, rad/s
%                          state(19): current x-position,  x, m
%                          state(20): current y-position,  y, m
%                          state(24): heading angle,       psi, rad
%   stepSize_time       main simulation stepsize, 
%
% Outputs: 
%   state_derivative    derivative of state
%   state_out           output state
%
% Other m-files required: none
%
% Author: Dr. Kevin Worrall
% Last revision: 06-01-2021

%% Initialize elements not needed during this lab
ty = 0;
tx = 0;
fz = 0;
xtra_fric = 0;

%% Keep psi between -180 -> +180
if(state(24)>=(pi))
    state(24)=state(24)-(2*pi);
elseif(state(24)<-pi)
    state(24)=state(24)+(2*pi);
end

%% Set Variables
I1 = state(1);   % Current, Amps
w1 = state(2);   % Wheel speed, rad/s
t1 = state(3);   % Wheel torque, Nm
I2 = state(4);   % Current, Amps
w2 = state(5);   % Wheel speed, rad/s
t2 = state(6);   % Wheel torque, Nm
I3 = state(7);   % Current, Amps
w3 = state(8);   % Wheel speed, rad/s
t3 = state(9);   % Wheel torque, Nm
I4 = state(10);   % Current, Amps
w4 = state(11);   % Wheel speed, rad/s
t4 = state(12);   % Wheel torque, Nm
u = state(13);
v = state(14);
w = state(15);
p = state(16);
q = state(17);
r = state(18);
xx = state(19);  % xx because the input matrix is x
y = state(20);
z = state(21);
phi = state(22);
theta = state(23);
psi = state(24);

% Motor Input
Va1 = voltages(1);
Va2 = voltages(2);
Va3 = voltages(3);
Va4 = voltages(4);     

%% Setup Cosines and Sines
% Cosines
cphi = cos(phi); ctheta = cos(theta); cpsi = cos(psi);

% Sines
sphi = sin(phi); stheta = sin(theta); spsi = sin(psi);

%% Robot Specifications
m = 2.148;          % Mass of robot, kg
wheel_r = 0.0635;   % Radius of Wheel, m
x_area = 0.0316;    % Area presented on the x-axis, m.m
y_area = 0.0448;    % Area presented on the y-axis, m.m
Jx = 0.0140;        % Moment of Inertia about the x-axis, kg.m.m
Jy = 0.0252;        % Moment of Inertia about the y-axis, kg.m.m
Jz = 0.0334;        % Moment of Inertia about the z-axis, kg.m.m
mr = 0.1245;        % Moment Arm

% Motor Spec's
Ra = 4;                         % Resistance of motor, Ohms
La = 0.1;                       % Inductance of motor, H
Kt = 0.35;                      % torque constant, Nm/A
Ke = 0.35;                      % EMF constant, V/rad/s
bs = 0.008;                     % Viscous torque, Nm 
Jm = 0.005;                     % Moment of Inertia for motor, kg m^2
fric_constant = 0.002+xtra_fric;% Friction acting on the wheel, Nm

% Constants
g = 9.81;           % Gravity, m/s.s
Cd = 0.89;          % Drag Coefficent
rho= 1.29;          % Air density
W = 21.0719;        % m*g; %Weight

%% Motor Calculations
% Motor 1
I1dot = ((-Ra*I1)-(Ke*w1)+Va1)/La;              % di/dt 
tau_friction = fric_constant*w1;
w1dot = ((Kt*I1)-(bs*w1)-tau_friction)/Jm;      % Acceleration
eff = (abs(I1)*-0.1330)+0.6;
if (Va1 == 0)
    t1dot = (0-t1)/stepSize_time;
else
    t1dot = (Kt*I1*eff-t1)/stepSize_time;                          % Torque
end

% Motor 2
I2dot = ((-Ra*I2)-(Ke*w2)+Va2)/La;              % di/dt 
tau_friction = fric_constant*w2;
w2dot = ((Kt*I2)-(bs*w2)-tau_friction)/Jm;      % Acceleration
eff = (abs(I2)*-0.1330)+0.6;
if (Va2 == 0)
    t2dot = (0-t2)/stepSize_time;
else
    t2dot = (Kt*I2*eff-t2)/stepSize_time;                          % Torque
end

% Motor 3
I3dot = ((-Ra*I3)-(Ke*w3)+Va3)/La;              % di/dt 
tau_friction = fric_constant*w3;
w3dot = ((Kt*I3)-(bs*w3)-tau_friction)/Jm;      % Acceleration
eff = (abs(I3)*-0.1330)+0.6;
if (Va3 == 0)
    t3dot = 0-(t3/stepSize_time);
else
    t3dot = (Kt*I3*eff-t3)/stepSize_time;                          % Torque
end

% Motor 4
I4dot = ((-Ra*I4)-(Ke*w4)+Va4)/La;              % di/dt 
tau_friction = fric_constant*w4;
w4dot = ((Kt*I4)-(bs*w4)-tau_friction)/Jm;      % Acceleration
eff = (abs(I4)*-0.1330)+0.6;
if (Va4 == 0)
    t4dot = (0-t4)/stepSize_time;
else
    t4dot = (Kt*I4*eff-t4)/stepSize_time;                          % Torque
end

%% Input Forces
% Calculated from the torques generated by the wheels. 
force_l1 = (t1/wheel_r);
force_l2 = (t2/wheel_r);
force_r1 = (t3/wheel_r);
force_r2 = (t4/wheel_r);

%% Slip
% calculates the slip angle for each wheel
bottom = sqrt((u^2)+(v^2));   % calculate denominator

if bottom == 0                   % check if 0,
    beta = 0;                    %   if 0 then no movement, no slip
else
    beta = asin(v/bottom);       % else calculate slip
end

%% Propulsion Forces
surge = (force_l1+force_l2+force_r1+force_r2)*cos(beta);
sway = (force_l1+force_l2+force_r1+force_r2)*sin(beta);
heave = fz;
roll = tx;
pitch = ty;
yaw = ((force_l1+force_l2)-(force_r1+force_r2))*mr;

%% Dampening Terms
fric_k = 0.35;
fric_m = 0.44;
fric_x = 0.22;
fric_n = 0.18;
fric_y = 1;
fric_z = 0.3;

% Friction
Fx_fric = 4.6358*u;     % W*fric_x*u;
Fy_fric = 21.0719*v;    % W*fric_y*v;
Fz_fric = 6.3216*w;     % W*fric_z*w;
K_fric = 0.9182*p;      % W*fric_k*mr*p;
M_fric = 1.1543*q;      % W*fric_m*mr*q;
N_fric = 0.4722*r;      % W*fric_n*mr*r;

% Air Resistance
% x-axis
Fx_ar = 0.0181*u*abs(u); % 0.5*Cd*x_area*rho*u*abs(u);

% Total Dampening
X_damp = Fx_fric+Fx_ar;
Y_damp = Fy_fric;
Z_damp = Fz_fric;
K_damp = K_fric;
M_damp = M_fric;
N_damp = N_fric;

%% Gravity Terms
X_grav = W*stheta;
Y_grav = W*sphi*ctheta;
Z_grav = (W*ctheta*cphi)-W;

%% Forces and Torques
% Forces
X = surge-X_damp+X_grav;
Y = sway-Y_damp+Y_grav;
Z = heave-Z_damp+Z_grav;

% Torques
K = roll-K_damp;
M = pitch-M_damp;
N = yaw-N_damp;

%% Equations of Motion
% Linear Accelerations
udot = (X/m)+(v*r)-(w*q);
vdot = (Y/m)+(w*p)-(u*r);
wdot = (Z/m)+(u*q)-(v*p);

% Rotational Accelerations
pdot = (K-((Jz-Jy)*q*r))/Jx;
qdot = (M-((Jx-Jz)*r*p))/Jy;
rdot = (N-((Jy-Jx)*p*q))/Jz;

%% Kinematics
% Linear Kinematics
xxdot = ((cpsi*ctheta)*u)+(((-spsi*cphi)-(cpsi*stheta*sphi))*v)+(((spsi*sphi)-(cpsi*stheta*cphi))*w); 
    % xxdot because xdot is the output matrix
ydot = ((spsi*ctheta)*u)+(((cpsi*cphi)-(spsi*stheta*sphi))*v)+(((-sphi*cpsi)-(spsi*cphi*stheta))*w);
zdot = ((stheta)*u)+((ctheta*sphi)*v)+((ctheta*cphi)*w);

% Angular Kinematics
% In theory +/-90 degrees for pitch is undefined but matlab tan()
% gives it a figure. Also this situation should not occur.
ttheta = tan(theta);
phidot = p+((-sphi*ttheta)*q)+((cphi*ttheta)*r); 
thetadot = ((cphi)*q)+((sphi)*r);
psidot = ((-sphi/ctheta)*q)+((cphi/ctheta)*r);

%% Assign variables to ouput
state_derivative(1) = I1dot;
state_derivative(2) = w1dot;    
state_derivative(3) = t1dot;
state_derivative(4) = I2dot;
state_derivative(5) = w2dot;
state_derivative(6) = t2dot;
state_derivative(7) = I3dot;
state_derivative(8) = w3dot;    
state_derivative(9) = t3dot;
state_derivative(10) = I4dot;
state_derivative(11) = w4dot;
state_derivative(12) = t4dot;
state_derivative(13) = udot;
state_derivative(14) = vdot;    
state_derivative(15) = wdot;
state_derivative(16) = pdot;
state_derivative(17) = qdot;
state_derivative(18) = rdot;
state_derivative(19) = xxdot;
state_derivative(20) = ydot;    
state_derivative(21) = zdot;
state_derivative(22) = phidot;
state_derivative(23) = thetadot;
state_derivative(24) = psidot;
%---------------------------------------------------------------------%

state_out = state; % updates x(24)
end